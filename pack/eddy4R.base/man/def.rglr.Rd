% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/def.rglr.R
\name{def.rglr}
\alias{def.rglr}
\title{Resampling irregular data to strictly regular / equidistant data}
\usage{
def.rglr(timeMeas, dataMeas, unitMeas = NULL, BgnRglr = NULL,
  EndRglr = NULL, TzRglr = attributes(BgnRglr)$tzone, FreqRglr,
  MethRglr = "zoo")
}
\arguments{
\item{\code{timeMeas}}{A vector containing the observation times. Of class "POSIXlt" including timezone attribute, and of the same length as \code{dataMeas}. [-]}

\item{\code{dataMeas}}{A named data.frame containing the observations. Columns may be of class "numeric" or "integer", and of the same length as \code{timeMeas}. Columns of classes other than "numeric" or "integer" are removed and not included in the returned \code{dataRegl}. [user-defined]}

\item{\code{unitMeas}}{A vector containing the unit of each column in \code{dataMeas}. Of class "character". It is recommended to conform to the "unit representation" guidelines documented in the eddy4R.base package.}

\item{\code{BgnRglr}}{Desired begin time for the regularized dataset. Of class "POSIXlt" including timezone attribute, and \code{length(BgnRglr) = 1}. This input is not used in the "cybiDflt" method. [-]}

\item{\code{EndRglr}}{Desired end time for the regularized dataset. Of class "POSIXlt" including timezone attribute, and \code{length(EndRglr) = 1}. This input is not used in the "cybiDflt" method. [-]}

\item{\code{TzRglr}}{Desired timezone for the regularized dataset. Of class "character" and \code{length(TzRglr) = 1}, defaults to the same timezone as \code{BgnRglr}. This input is not used in the "cybiDflt" method. [-]}

\item{\code{FreqRglr}}{Desired frequency of  the regularized dataset. Of class "numeric" or "integer" and \code{length(FreqRglr) = 1}. [Hz]}

\item{\code{MethRglr}}{Switch for different regularization methods. Of class "character", currently defaults to "zoo". [-] \cr
Method "cybiDflt" implements the default regularization performed by NEON CI. Namely, a new time series is created 
from the first measurement time, rounded toward zero, using the expected data frequency. The first measurement falling 
in between one time stamp and the next is assigned to the first of these, and all other measurements falling in this range are ignored.}
}
\value{
Returns a list with elements \code{TzRglr}, \code{FreqRglr}, \code{MethRglr}, \code{timeRglr}, and \code{dataRglr}.
}
\description{
Function defintion. 
Takes a (potentially) irregularly spaced timeseries \code{timeMeas} of data \code{dataMeas} and returns a strictuly regularly spaced timeseries \code{timeRegl} of data \code{dataRegl}. \strong{ATTENTION}: \code{MethRglr = "zoo"} uses the zoo:na.approx() function, which does not currently abide by its \code{maxgap} argument. In result, where gaps exist currently the last known value is repeated instead of NAs being inserted. An Email with a request for bugfixing has been sent to \email{Achim.Zeileis@R-project.org} (2016-05-08).
}
\examples{
# make sure that fractional seconds can be seen from the console
options(digits.secs=3)
# assign measured time vector
timeMeas <- base::as.POSIXlt(seq.POSIXt(
  from = base::as.POSIXlt("2016-01-01 00:00:00.001", format="\%Y-\%m-\%d \%H:\%M:\%OS", tz="UTC"),
  to = base::as.POSIXlt("2016-01-01 00:00:01.002", format="\%Y-\%m-\%d \%H:\%M:\%OS", tz="UTC"),
  by = 1/10), tz = "UTC")[-c(5,6,8)]
# assign fake observations
dataMeas <- base::data.frame("wind01" = rnorm(base::length(timeMeas)), "wind02" = rnorm(base::length(timeMeas))),
# regularize
def.rglr(
  timeMeas = timeMeas,
  dataMeas = dataMeas,
  unitMeas = c("metersPerSecond", "metersPerSecond"),
  BgnRglr = base::as.POSIXlt("2016-01-01 00:00:00.000", format="\%Y-\%m-\%d \%H:\%M:\%OS", tz="UTC"),
  EndRglr = base::as.POSIXlt("2016-01-01 00:00:01.000", format="\%Y-\%m-\%d \%H:\%M:\%OS", tz="UTC"),
  FreqRglr = 10,
  MethRglr = "zoo"
)
}
\author{
Stefan Metzger \email{eddy4R.info@gmail.com}
}
\references{
License: Terms of use of the NEON FIU algorithm repository dated 2015-01-16. \cr
}
\seealso{
?zoo:na.approx, ?stats::approx
}
\keyword{equidistant}
\keyword{regularization,}

